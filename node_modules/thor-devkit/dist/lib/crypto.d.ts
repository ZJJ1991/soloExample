/// <reference types="node" />
/**
 * computes blake2b 256bit hash of given data
 * @param data one or more Buffer | string
 */
export declare function blake2b256(...data: Array<Buffer | string>): Buffer;
/**
 * computes keccak256 hash of given data
 * @param data one or more Buffer | string
 */
export declare function keccak256(...data: Array<Buffer | string>): Buffer;
/**
 * derive Address from public key
 * @param pubKey the public key
 */
export declare function publicKeyToAddress(pubKey: Buffer): Buffer;
/** secp256k1 methods set */
export declare namespace secp256k1 {
    /** generate private key  */
    function generatePrivateKey(): Buffer;
    /**
     * derive public key(uncompressed) from private key
     * @param privKey the private key
     */
    function derivePublicKey(privKey: Buffer): Buffer;
    /**
     * sign a message using elliptic curve algorithm on the curve secp256k1
     * @param msgHash hash of message
     * @param privKey serialized private key
     */
    function sign(msgHash: Buffer, privKey: Buffer): Buffer;
    /**
     * recovery signature to public key
     * @param msgHash hash of message
     * @param sig signature
     */
    function recover(msgHash: Buffer, sig: Buffer): Buffer;
}
/** to present encrypted private key in Ethereum keystore format. */
export interface Keystore {
    address: string;
    crypto: object;
    id: string;
    version: number;
}
export declare namespace Keystore {
    /**
     * encrypt private key to keystore with given password
     * @param privateKey the private key to be encrypted
     * @param password password to encrypt the private key
     */
    function encrypt(privateKey: Buffer, password: string): Promise<Keystore>;
    /**
     * decrypt private key from keystore
     * an error thrown if not well formed
     * @param ks the keystore
     * @param password password to decrypt keystore
     */
    function decrypt(ks: Keystore, password: string): Promise<Buffer>;
    /**
     * roughly check whether keystore is well formed
     * @param ks the keystore
     */
    function wellFormed(ks: any): ks is Keystore;
}
export declare namespace mnemonic {
    /** generate BIP39 mnemonic words */
    function generate(): string[];
    /**
     * check if the given mnemonic words have valid checksum
     * @param words mnemonic words
     */
    function validate(words: string[]): boolean;
    /**
     * derive private key from mnemonic words according to BIP32.
     * the derivation path is defined at https://github.com/satoshilabs/slips/blob/master/slip-0044.md
     */
    function derivePrivateKey(words: string[]): Buffer;
}
