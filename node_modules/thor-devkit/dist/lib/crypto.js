"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const keccak = require('keccak');
const blake = require('blakejs');
/**
 * computes blake2b 256bit hash of given data
 * @param data one or more Buffer | string
 */
function blake2b256(...data) {
    const ctx = blake.blake2bInit(32, null);
    data.forEach(d => {
        if (Buffer.isBuffer(d)) {
            blake.blake2bUpdate(ctx, d);
        }
        else {
            blake.blake2bUpdate(ctx, Buffer.from(d, 'utf8'));
        }
    });
    return Buffer.from(blake.blake2bFinal(ctx));
}
exports.blake2b256 = blake2b256;
/**
 * computes keccak256 hash of given data
 * @param data one or more Buffer | string
 */
function keccak256(...data) {
    const h = keccak('keccak256');
    data.forEach(d => {
        if (Buffer.isBuffer(d)) {
            h.update(d);
        }
        else {
            h.update(Buffer.from(d, 'utf8'));
        }
    });
    return h.digest();
}
exports.keccak256 = keccak256;
/**
 * derive Address from public key
 * @param pubKey the public key
 */
function publicKeyToAddress(pubKey) {
    return keccak256(pubKey.slice(1)).slice(12);
}
exports.publicKeyToAddress = publicKeyToAddress;
const secp256k1Funs = require('secp256k1');
/** secp256k1 methods set */
var secp256k1;
(function (secp256k1) {
    /** generate private key  */
    function generatePrivateKey() {
        for (;;) {
            const privKey = crypto_1.randomBytes(32);
            if (secp256k1Funs.privateKeyVerify(privKey)) {
                return privKey;
            }
        }
    }
    secp256k1.generatePrivateKey = generatePrivateKey;
    /**
     * derive public key(uncompressed) from private key
     * @param privKey the private key
     */
    function derivePublicKey(privKey) {
        return secp256k1Funs.publicKeyCreate(privKey, false /* uncompressed */);
    }
    secp256k1.derivePublicKey = derivePublicKey;
    /**
     * sign a message using elliptic curve algorithm on the curve secp256k1
     * @param msgHash hash of message
     * @param privKey serialized private key
     */
    function sign(msgHash, privKey) {
        const sig = secp256k1Funs.sign(msgHash, privKey);
        const packed = Buffer.alloc(65);
        sig.signature.copy(packed);
        packed[64] = sig.recovery;
        return packed;
    }
    secp256k1.sign = sign;
    /**
     * recovery signature to public key
     * @param msgHash hash of message
     * @param sig signature
     */
    function recover(msgHash, sig) {
        if (sig.length !== 65) {
            throw new Error('invalid signature');
        }
        const recovery = sig[64];
        if (recovery !== 0 && recovery !== 1) {
            throw new Error('invalid signature recovery');
        }
        return secp256k1Funs.recover(msgHash, sig.slice(0, 64), recovery, false);
    }
    secp256k1.recover = recover;
})(secp256k1 = exports.secp256k1 || (exports.secp256k1 = {}));
const Keythereum = require('keythereum');
var Keystore;
(function (Keystore) {
    /**
     * encrypt private key to keystore with given password
     * @param privateKey the private key to be encrypted
     * @param password password to encrypt the private key
     */
    function encrypt(privateKey, password) {
        return new Promise((resolve, reject) => {
            if (!secp256k1Funs.privateKeyVerify(privateKey)) {
                return reject(new Error('invalid private key'));
            }
            Keythereum.dump(password, privateKey, crypto_1.randomBytes(32), crypto_1.randomBytes(16), {
                cipher: 'aes-128-ctr',
                kdf: 'scrypt',
                kdfparams: {
                    dklen: 32,
                    memory: 280000000,
                    n: 262144,
                    p: 1,
                    r: 8,
                },
            }, resolve);
        });
    }
    Keystore.encrypt = encrypt;
    /**
     * decrypt private key from keystore
     * an error thrown if not well formed
     * @param ks the keystore
     * @param password password to decrypt keystore
     */
    function decrypt(ks, password) {
        return new Promise((resolve, reject) => {
            Keythereum.recover(password, validate(normalize(ks)), (r) => {
                if (!Buffer.isBuffer(r)) {
                    return reject(r);
                }
                resolve(r);
            });
        });
    }
    Keystore.decrypt = decrypt;
    /**
     * roughly check whether keystore is well formed
     * @param ks the keystore
     */
    function wellFormed(ks) {
        try {
            validate(normalize(ks));
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    Keystore.wellFormed = wellFormed;
    /** normalize keystore. e.g. lower case keys */
    function normalize(obj) {
        const lowerKey = (o) => {
            return Object.keys(o).reduce((converted, k) => {
                let v = o[k];
                if (typeof v === 'object') {
                    v = lowerKey(v);
                }
                converted[k.toLowerCase()] = v;
                return converted;
            }, {});
        };
        return lowerKey(obj);
    }
    function validate(ks) {
        if (ks.version !== 1 && ks.version !== 3) {
            throw new Error('unsupported version');
        }
        if (!/^[0-9a-f]{40}$/i.test(ks.address)) {
            throw new Error('invalid address');
        }
        if (!/^[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}$/i.test(ks.id)) {
            throw new Error('invalid id');
        }
        if (typeof ks.crypto !== 'object') {
            throw new Error('invalid crypto');
        }
        return ks;
    }
})(Keystore = exports.Keystore || (exports.Keystore = {}));
const BIP39 = require("bip39");
const HDKey = require("hdkey");
var mnemonic;
(function (mnemonic) {
    // see https://github.com/satoshilabs/slips/blob/master/slip-0044.md
    const VET_DERIVATION_PATH = `m/44'/818'/0'/0`;
    /** generate BIP39 mnemonic words */
    function generate() {
        return BIP39.generateMnemonic(128, crypto_1.randomBytes).split(' ');
    }
    mnemonic.generate = generate;
    /**
     * check if the given mnemonic words have valid checksum
     * @param words mnemonic words
     */
    function validate(words) {
        return BIP39.validateMnemonic(words.join(' '));
    }
    mnemonic.validate = validate;
    /**
     * derive private key from mnemonic words according to BIP32.
     * the derivation path is defined at https://github.com/satoshilabs/slips/blob/master/slip-0044.md
     */
    function derivePrivateKey(words) {
        const seed = BIP39.mnemonicToSeed(words.join(' '));
        const hdKey = HDKey.fromMasterSeed(seed);
        return hdKey.derive(VET_DERIVATION_PATH + '/0').privateKey;
    }
    mnemonic.derivePrivateKey = derivePrivateKey;
})(mnemonic = exports.mnemonic || (exports.mnemonic = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi9jcnlwdG8udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQ0FBb0M7QUFDcEMsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFBO0FBQ2hDLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQTtBQUVoQzs7O0dBR0c7QUFDSCxvQkFBMkIsR0FBRyxJQUE0QjtJQUN0RCxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQTtJQUN2QyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ2IsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ3BCLEtBQUssQ0FBQyxhQUFhLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFBO1NBQzlCO2FBQU07WUFDSCxLQUFLLENBQUMsYUFBYSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFBO1NBQ25EO0lBQ0wsQ0FBQyxDQUFDLENBQUE7SUFDRixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO0FBQy9DLENBQUM7QUFWRCxnQ0FVQztBQUVEOzs7R0FHRztBQUNILG1CQUEwQixHQUFHLElBQTRCO0lBQ3JELE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQTtJQUM3QixJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ2IsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ3BCLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUE7U0FDZDthQUFNO1lBQ0gsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFBO1NBQ25DO0lBQ0wsQ0FBQyxDQUFDLENBQUE7SUFDRixPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQVksQ0FBQTtBQUMvQixDQUFDO0FBVkQsOEJBVUM7QUFFRDs7O0dBR0c7QUFDSCw0QkFBbUMsTUFBYztJQUM3QyxPQUFPLFNBQVMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFBO0FBQy9DLENBQUM7QUFGRCxnREFFQztBQUVELE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQTtBQUUxQyw0QkFBNEI7QUFDNUIsSUFBaUIsU0FBUyxDQWdEekI7QUFoREQsV0FBaUIsU0FBUztJQUN0Qiw0QkFBNEI7SUFDNUI7UUFDSSxTQUFVO1lBQ04sTUFBTSxPQUFPLEdBQUcsb0JBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQTtZQUMvQixJQUFJLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDekMsT0FBTyxPQUFPLENBQUE7YUFDakI7U0FDSjtJQUNMLENBQUM7SUFQZSw0QkFBa0IscUJBT2pDLENBQUE7SUFFRDs7O09BR0c7SUFDSCx5QkFBZ0MsT0FBZTtRQUMzQyxPQUFPLGFBQWEsQ0FBQyxlQUFlLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxrQkFBa0IsQ0FBVyxDQUFBO0lBQ3JGLENBQUM7SUFGZSx5QkFBZSxrQkFFOUIsQ0FBQTtJQUVEOzs7O09BSUc7SUFDSCxjQUFxQixPQUFlLEVBQUUsT0FBZTtRQUNqRCxNQUFNLEdBQUcsR0FBRyxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQTtRQUNoRCxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFBO1FBQy9CLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFBO1FBQzFCLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsUUFBUSxDQUFBO1FBQ3pCLE9BQU8sTUFBTSxDQUFBO0lBQ2pCLENBQUM7SUFOZSxjQUFJLE9BTW5CLENBQUE7SUFFRDs7OztPQUlHO0lBQ0gsaUJBQXdCLE9BQWUsRUFBRSxHQUFXO1FBQ2hELElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxFQUFFLEVBQUU7WUFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFBO1NBQ3ZDO1FBQ0QsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFBO1FBQ3hCLElBQUksUUFBUSxLQUFLLENBQUMsSUFBSSxRQUFRLEtBQUssQ0FBQyxFQUFFO1lBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQTtTQUNoRDtRQUVELE9BQU8sYUFBYSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBVyxDQUFBO0lBQ3RGLENBQUM7SUFWZSxpQkFBTyxVQVV0QixDQUFBO0FBQ0wsQ0FBQyxFQWhEZ0IsU0FBUyxHQUFULGlCQUFTLEtBQVQsaUJBQVMsUUFnRHpCO0FBRUQsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFBO0FBVXhDLElBQWlCLFFBQVEsQ0FxRnhCO0FBckZELFdBQWlCLFFBQVE7SUFDckI7Ozs7T0FJRztJQUNILGlCQUF3QixVQUFrQixFQUFFLFFBQWdCO1FBQ3hELE9BQU8sSUFBSSxPQUFPLENBQVcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDN0MsSUFBSSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDN0MsT0FBTyxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFBO2FBQ2xEO1lBQ0QsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLG9CQUFXLENBQUMsRUFBRSxDQUFDLEVBQUUsb0JBQVcsQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDcEUsTUFBTSxFQUFFLGFBQWE7Z0JBQ3JCLEdBQUcsRUFBRSxRQUFRO2dCQUNiLFNBQVMsRUFBRTtvQkFDUCxLQUFLLEVBQUUsRUFBRTtvQkFDVCxNQUFNLEVBQUUsU0FBUztvQkFDakIsQ0FBQyxFQUFFLE1BQU07b0JBQ1QsQ0FBQyxFQUFFLENBQUM7b0JBQ0osQ0FBQyxFQUFFLENBQUM7aUJBQ1A7YUFDSixFQUFFLE9BQU8sQ0FBQyxDQUFBO1FBQ2YsQ0FBQyxDQUFDLENBQUE7SUFDTixDQUFDO0lBakJlLGdCQUFPLFVBaUJ0QixDQUFBO0lBRUQ7Ozs7O09BS0c7SUFDSCxpQkFBd0IsRUFBWSxFQUFFLFFBQWdCO1FBQ2xELE9BQU8sSUFBSSxPQUFPLENBQVMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDM0MsVUFBVSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBaUIsRUFBRSxFQUFFO2dCQUN4RSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDckIsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUE7aUJBQ25CO2dCQUNELE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUNkLENBQUMsQ0FBQyxDQUFBO1FBQ04sQ0FBQyxDQUFDLENBQUE7SUFDTixDQUFDO0lBVGUsZ0JBQU8sVUFTdEIsQ0FBQTtJQUVEOzs7T0FHRztJQUNILG9CQUEyQixFQUFPO1FBQzlCLElBQUk7WUFDQSxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUE7WUFDdkIsT0FBTyxJQUFJLENBQUE7U0FDZDtRQUFDLFdBQU07WUFDSixPQUFPLEtBQUssQ0FBQTtTQUNmO0lBQ0wsQ0FBQztJQVBlLG1CQUFVLGFBT3pCLENBQUE7SUFFRCwrQ0FBK0M7SUFDL0MsbUJBQW1CLEdBQVc7UUFDMUIsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFTLEVBQUUsRUFBRTtZQUMzQixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUMxQyxJQUFJLENBQUMsR0FBSSxDQUFTLENBQUMsQ0FBQyxDQUFDLENBQUE7Z0JBQ3JCLElBQUksT0FBTyxDQUFDLEtBQUssUUFBUSxFQUFFO29CQUN2QixDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFBO2lCQUNsQjtnQkFDRCxTQUFTLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFBO2dCQUM5QixPQUFPLFNBQVMsQ0FBQTtZQUNwQixDQUFDLEVBQUUsRUFBUyxDQUFDLENBQUE7UUFDakIsQ0FBQyxDQUFBO1FBQ0QsT0FBTyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDeEIsQ0FBQztJQUVELGtCQUFrQixFQUFZO1FBQzFCLElBQUksRUFBRSxDQUFDLE9BQU8sS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLE9BQU8sS0FBSyxDQUFDLEVBQUU7WUFDdEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFBO1NBQ3pDO1FBQ0QsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDckMsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBO1NBQ3JDO1FBQ0QsSUFBSSxDQUFDLGlFQUFpRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDaEYsTUFBTSxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQTtTQUNoQztRQUNELElBQUksT0FBTyxFQUFFLENBQUMsTUFBTSxLQUFLLFFBQVEsRUFBRTtZQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUE7U0FDcEM7UUFDRCxPQUFPLEVBQUUsQ0FBQTtJQUNiLENBQUM7QUFDTCxDQUFDLEVBckZnQixRQUFRLEdBQVIsZ0JBQVEsS0FBUixnQkFBUSxRQXFGeEI7QUFFRCwrQkFBK0I7QUFDL0IsK0JBQStCO0FBRS9CLElBQWlCLFFBQVEsQ0EwQnhCO0FBMUJELFdBQWlCLFFBQVE7SUFDckIsb0VBQW9FO0lBQ3BFLE1BQU0sbUJBQW1CLEdBQUcsaUJBQWlCLENBQUE7SUFFN0Msb0NBQW9DO0lBQ3BDO1FBQ0ksT0FBTyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxFQUFFLG9CQUFXLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDOUQsQ0FBQztJQUZlLGlCQUFRLFdBRXZCLENBQUE7SUFFRDs7O09BR0c7SUFDSCxrQkFBeUIsS0FBZTtRQUNwQyxPQUFPLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUE7SUFDbEQsQ0FBQztJQUZlLGlCQUFRLFdBRXZCLENBQUE7SUFFRDs7O09BR0c7SUFDSCwwQkFBaUMsS0FBZTtRQUM1QyxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtRQUNsRCxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQ3hDLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUE7SUFDOUQsQ0FBQztJQUplLHlCQUFnQixtQkFJL0IsQ0FBQTtBQUNMLENBQUMsRUExQmdCLFFBQVEsR0FBUixnQkFBUSxLQUFSLGdCQUFRLFFBMEJ4QiJ9